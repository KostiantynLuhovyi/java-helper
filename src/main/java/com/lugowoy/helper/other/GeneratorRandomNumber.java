package com.lugowoy.helper.other;

import org.apache.commons.lang3.RandomUtils;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * Interface with static functionality for generate random number.
 * <p>Created by Konstantin Lugowoy on 01.01.2018.
 *
 * @author Konstantin Lugowoy
 * @version 1.6
 */
public interface GeneratorRandomNumber {

    /**
     * Value of digits after the decimal point in double numbers.
     */
    int SCALE = 3;

    /**
     * The default zero value for some methods.
     */
    int DEFAULT_ZERO_VALUE = 0;

    /**
     * Generate a random byte number in the range (inclusive)
     * from {@link Byte#MIN_VALUE} to {@link Byte#MAX_VALUE}.
     *
     * @return The generated byte number.
     */
    static byte generateByte() {
        return (byte) RandomUtils.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE);
    }

    /**
     * Generate a random positive byte number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound.
     *
     * @param bound The bound number to generate.
     * @return The generated byte number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static byte generateByte(byte bound) {
        if (bound > 0 && bound <= Byte.MAX_VALUE) {
            return (byte) RandomUtils.nextInt(DEFAULT_ZERO_VALUE, Byte.MAX_VALUE);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random byte number in the range (inclusive)
     * from parameter startBound to endBound.
     *
     * @param startBound The start bound to generate.
     * @param endBound The start bound to generate.
     * @return The generated byte number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static byte generateByte(byte startBound, byte endBound) {
        if ((startBound > Byte.MIN_VALUE && endBound < Byte.MAX_VALUE) && (startBound < endBound)) {
            return (byte) RandomUtils.nextInt(startBound, endBound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random short number in the range (inclusive)
     * from {@link Short#MIN_VALUE} to {@link Short#MAX_VALUE}.
     *
     * @return The generated short number.
     */
    static short generateShort() {
        return (short) RandomUtils.nextInt(Short.MIN_VALUE, Short.MIN_VALUE);
    }

    /**
     * Generate a random positive short number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound.
     *
     * @param bound The bound number to generate.
     * @return The generated short number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static short generateShort(short bound) {
        if (bound > 0 && bound < Short.MAX_VALUE) {
            return (short) RandomUtils.nextInt(DEFAULT_ZERO_VALUE, bound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random short number in the range (inclusive)
     * from parameter startBound to parameter endBound.
     *
     * @param startBound The min bound to generate.
     * @param endBound The min bound to generate.
     * @return The generated short number.
     */
    static short generateShort(short startBound, short endBound) {
        if ((startBound > Short.MIN_VALUE && endBound < Short.MAX_VALUE) && (startBound < endBound)) {
            return (short) RandomUtils.nextInt(startBound, endBound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random integer number in the range (inclusive)
     * from {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}.
     *
     * @return The generated integer number.
     */
    static int generateInt() {
        return RandomUtils.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    /**
     * Generate a random positive integer number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound.
     *
     * @param bound The bound to generate.
     * @return The generated integer number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static int generateInt(int bound) {
        if (bound > 0 && bound < Integer.MAX_VALUE) {
            return RandomUtils.nextInt(DEFAULT_ZERO_VALUE, bound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random integer number in the range (inclusive)
     * from parameter startBound to parameter endBound.
     *
     * @param startBound The min bound to generate.
     * @param endBound The max bound to generate.
     * @return The generated integer number.
     */
    static int generateInt(int startBound, int endBound) {
        if ((startBound > Integer.MIN_VALUE && endBound < Integer.MAX_VALUE) && (startBound < endBound)) {
            return RandomUtils.nextInt(startBound, endBound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random long number in the range (inclusive)
     * from {@link Long#MIN_VALUE} to {@link Long#MAX_VALUE}.
     *
     * @return The generated long number.
     */
    static long generateLong() {
        return RandomUtils.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);
    }

    /**
     * Generate a random positive long number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound.
     *
     * @param bound The bound to generate.
     * @return The generated long number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static long generateLong(long bound) {
        if (bound > 0 && bound < Long.MAX_VALUE) {
            return RandomUtils.nextLong(DEFAULT_ZERO_VALUE, bound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random long number in the range (inclusive)
     * from parameter startBound to endBound.
     *
     * @param startBound The start bound to generate.
     * @param endBound The end bound to generate.
     * @return The generated long number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static long generateLong(long startBound, long endBound) {
        if ((startBound > Long.MIN_VALUE && endBound < Long.MAX_VALUE) && (startBound < endBound)) {
            return RandomUtils.nextLong(startBound, endBound);
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random double number in the range (inclusive)
     * from {@link Long#MIN_VALUE} to {@link Long#MAX_VALUE}.
     *
     * @return The generated double number.
     */
    static double generateDouble() {
        double resultDouble = RandomUtils.nextDouble(Long.MIN_VALUE, Long.MAX_VALUE);
        return new BigDecimal(resultDouble).setScale(SCALE, RoundingMode.HALF_DOWN).doubleValue();
    }

    /**
     * Generate a random positive double number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound ({@link Long#MAX_VALUE}).
     *
     * @param bound The bound to generate.
     * @return The generated double number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static double generateDouble(double bound) {
        if (bound > 0 && bound < Long.MAX_VALUE) {
            double resultDouble = RandomUtils.nextDouble(Long.MIN_VALUE, Long.MAX_VALUE);
            return new BigDecimal(resultDouble).setScale(SCALE, RoundingMode.HALF_DOWN).doubleValue();
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random double number in the range (inclusive)
     * from parameter startBound to endBound.
     *
     * @param startBound The start bound to generate.
     * @param endBound The end bound to generate.
     * @return The generated double number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static double generateDouble(double startBound, double endBound) {
        if ((startBound > Long.MIN_VALUE && startBound < Long.MAX_VALUE) && (startBound < endBound)) {
            double resultDouble = RandomUtils.nextDouble(Long.MIN_VALUE, Long.MAX_VALUE);
            return new BigDecimal(resultDouble).setScale(SCALE, RoundingMode.HALF_DOWN).doubleValue();
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random float number in the range (inclusive)
     * from {@link Long#MIN_VALUE} to {@link Long#MAX_VALUE}.
     *
     * @return The generated float number.
     */
    static float generateFloat() {
        float resultFloat = RandomUtils.nextFloat(Long.MIN_VALUE, Long.MAX_VALUE);
        return new BigDecimal(resultFloat).setScale(SCALE, RoundingMode.HALF_DOWN).floatValue();
    }

    /**
     * Generate a random positive float number in the range (inclusive)
     * from {@link GeneratorRandomNumber#DEFAULT_ZERO_VALUE} to parameter bound.
     *
     * @param bound The bound to generate.
     * @return The generated float number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static float generateFloat(float bound) {
        if (bound > 0 && bound < Long.MAX_VALUE) {
            float resultFloat = RandomUtils.nextFloat(Long.MIN_VALUE, Long.MAX_VALUE);
            return new BigDecimal(resultFloat).setScale(SCALE, RoundingMode.HALF_DOWN).floatValue();
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    /**
     * Generate a random float number in the range (inclusive)
     * from parameter startBound to parameter endBound.
     *
     * @param startBound The start bound to generate.
     * @param endBound  The end bound to generate.
     * @return The generated float number.
     * @throws IncorrectBoundValueException If the bound is incorrect.
     */
    static float generateFloat(float startBound, float endBound) {
        if ((startBound > Long.MIN_VALUE && endBound < Long.MAX_VALUE) && (startBound < endBound)) {
            float resultFloat = RandomUtils.nextFloat(Long.MIN_VALUE, Long.MAX_VALUE);
            return new BigDecimal(resultFloat).setScale(SCALE, RoundingMode.HALF_DOWN).floatValue();
        } else {
            throw new IncorrectBoundValueException("Incorrect bound value.");
        }
    }

    final class IncorrectBoundValueException extends RuntimeException {

        /**
         * Constructs a new runtime exception with {@code null} as its
         * detail message.  The cause is not initialized, and may subsequently be
         * initialized by a call to {@link #initCause}.
         */
        public IncorrectBoundValueException() {
        }

        /**
         * Constructs a new runtime exception with the specified detail message.
         * The cause is not initialized, and may subsequently be initialized by a
         * call to {@link #initCause}.
         *
         * @param message the detail message. The detail message is saved for
         *                later retrieval by the {@link #getMessage()} method.
         */
        public IncorrectBoundValueException(String message) {
            super(message);
        }

        /**
         * Constructs a new runtime exception with the specified detail message and
         * cause.  <p>Note that the detail message associated with
         * {@code cause} is <i>not</i> automatically incorporated in
         * this runtime exception's detail message.
         *
         * @param message the detail message (which is saved for later retrieval
         *                by the {@link #getMessage()} method).
         * @param cause   the cause (which is saved for later retrieval by the
         *                {@link #getCause()} method).  (A {@code null} value is
         *                permitted, and indicates that the cause is nonexistent or
         *                unknown.)
         * @since 1.4
         */
        public IncorrectBoundValueException(String message, Throwable cause) {
            super(message, cause);
        }

        /**
         * Constructs a new runtime exception with the specified cause and a
         * detail message of {@code (cause==null ? null : cause.toString())}
         * (which typically contains the class and detail message of
         * {@code cause}).  This constructor is useful for runtime exceptions
         * that are little more than wrappers for other throwables.
         *
         * @param cause the cause (which is saved for later retrieval by the
         *              {@link #getCause()} method).  (A {@code null} value is
         *              permitted, and indicates that the cause is nonexistent or
         *              unknown.)
         * @since 1.4
         */
        public IncorrectBoundValueException(Throwable cause) {
            super(cause);
        }

        /**
         * Constructs a new runtime exception with the specified detail
         * message, cause, suppression enabled or disabled, and writable
         * stack trace enabled or disabled.
         *
         * @param message            the detail message.
         * @param cause              the cause.  (A {@code null} value is permitted,
         *                           and indicates that the cause is nonexistent or unknown.)
         * @param enableSuppression  whether or not suppression is enabled
         *                           or disabled
         * @param writableStackTrace whether or not the stack trace should
         *                           be writable
         * @since 1.7
         */
        public IncorrectBoundValueException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
            super(message, cause, enableSuppression, writableStackTrace);
        }

    }

}
